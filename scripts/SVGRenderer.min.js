class SVGRenderer extends HTMLElement {
  constructor() {
    super();
    this.eventListeners = new Map();
    this.attachShadow({ mode: "open" }); // keep internal <svg>
  }

  static get observedAttributes() {
    return [
      "data-src",
      "width",
      "height",
      "fill",
      "background",
      "data-js",
      "style",
      "replace",
      "class",
      "fit",
    ];
  }

  get replace() {
    const attr = this.getAttribute("replace");
    return attr === null || attr === "true";
  }

  get isJsEnabled() {
    const value = this.getAttribute("data-js");
    return value === null || value === "enabled";
  }

  async connectedCallback() {
    await this.loadSVG();
  }

  async attributeChangedCallback(name, oldValue, newValue) {
    if (oldValue === newValue) return;

    if (name === "data-src") {
      await this.loadSVG(); // redraw
    } else if (name === "data-js") {
      this.updateEventHandling();
    } else {
      if (this.svgContent) this.applyStyles(this.svgContent);
    }
  }

  async loadSVG() {
    const src = this.getAttribute("data-src");
    this.svgContent = null;
    this.eventListeners.clear();

    if (!src) return;

    try {
      let svgText = localStorage.getItem(src);
      if (!svgText) {
        const res = await fetch(src);
        if (!res.ok) throw new Error("Failed to fetch SVG");
        svgText = await res.text();
        localStorage.setItem(src, svgText);
      }

      const tmp = document.createElement("div");
      tmp.innerHTML = svgText.trim();
      const svgEl = tmp.querySelector("svg");
      if (!svgEl) throw new Error("Invalid SVG content");

      Array.from(this.attributes).forEach((attr) => {
        if (attr.name !== "data-src") svgEl.setAttribute(attr.name, attr.value);
      });

      if (!this.replace) {
        svgEl.removeAttribute("id");
      }

      this.applyStyles(svgEl);

      if (this.replace) {
        this.replaceWith(svgEl);
      } else {
        if (this.shadowRoot) {
          this.shadowRoot.innerHTML = "";
          this.shadowRoot.appendChild(svgEl);
        } else {
          this.innerHTML = "";
          this.appendChild(svgEl);
        }
      }

      this.svgContent = svgEl;

      if (this.isJsEnabled) {
        this.updateEventHandling();
      }
    } catch (err) {
      console.error("Error loading SVG:", err);
      const errBox = document.createElement("div");
      errBox.style.color = "red";
      errBox.textContent = "Failed to load SVG";
      if (this.shadowRoot) {
        this.shadowRoot.innerHTML = "";
        this.shadowRoot.appendChild(errBox);
      } else {
        this.innerHTML = "";
        this.appendChild(errBox);
      }
    }
  }

  applyStyles(target) {
    const width = this.getAttribute("width"),
      height = this.getAttribute("height"),
      fill = this.getAttribute("fill") || "currentColor",
      background = this.getAttribute("background"),
      styleAttr = this.getAttribute("style"),
      fit = this.getAttribute("fit"),
      classAttr = this.getAttribute("class");

    if (width) target.setAttribute("width", width);
    if (height) target.setAttribute("height", height);
    if (background) target.style.background = background;
    if (classAttr) target.setAttribute("class", classAttr);

    target.setAttribute("preserveAspectRatio", "xMidYMid meet");

    if (fill) {
      target.style.fill = fill;
      target.style.color = fill;
      target.querySelectorAll("[fill]").forEach((el) => el.setAttribute("fill", fill));
    }

    if (styleAttr) {
      target.style.cssText += ";" + styleAttr;
      const colorMatch = styleAttr.match(/color\s*:\s*([^;]+);?/i);
      if (colorMatch) {
        const styleColor = colorMatch[1].trim();
        target.style.fill = styleColor;
        target.style.color = styleColor;
        target.querySelectorAll("[fill]").forEach((el) => el.setAttribute("fill", styleColor));
      }
    }

    if (fit === "true") {
      target.removeAttribute("width");
      target.removeAttribute("height");
      target.setAttribute("width", "100%");
      target.setAttribute("height", "100%");
      if (target.hasAttribute("style")) {
        let cleanedStyle = target
          .getAttribute("style")
          .replace(/width\s*:\s*[^;]+;?/gi, "")
          .replace(/height\s*:\s*[^;]+;?/gi, "")
          .trim();
        if (cleanedStyle) {
          target.setAttribute("style", cleanedStyle);
        } else {
          target.removeAttribute("style");
        }
      }
    }
  }

  updateEventHandling() {
    if (!this.svgContent) return;

    this.eventListeners.forEach((handler, event) => {
      this.svgContent.removeEventListener(event, handler);
    });
    this.eventListeners.clear();

    if (this.isJsEnabled) {
      const events = ["click", "mouseover", "mouseout", "mousedown", "mouseup"];
      events.forEach((event) => {
        const handler = (e) => {
          const clickEvent = new MouseEvent(event, {
            bubbles: true,
            cancelable: true,
            composed: true,
            detail: { originalEvent: e, svgElement: this.svgContent },
          });
          this.dispatchEvent(clickEvent);
        };
        this.svgContent.addEventListener(event, handler);
        this.eventListeners.set(event, handler);
      });
      this.svgContent.style.cursor = "pointer";
      this.svgContent.style.pointerEvents = "none";
    } else {
      this.svgContent.style.cursor = "default";
      this.svgContent.style.pointerEvents = "auto";
    }
  }

  addStyle(t, e) {
    if (this.svgContent) this.svgContent.style[t] = e; // Apply a single style
  }

  removeStyle(t) {
    if (this.svgContent) this.svgContent.style[t] = ""; // Remove a style
  }

  addClass(t) {
    if (this.svgContent) this.svgContent.classList.add(t); // Add a class
  }

  removeClass(t) {
    if (this.svgContent) this.svgContent.classList.remove(t); // Remove a class
  }

  toggleClass(t) {
    if (this.svgContent) this.svgContent.classList.toggle(t); // Toggle a class
  }
}

customElements.define("svg-renderer", SVGRenderer);
